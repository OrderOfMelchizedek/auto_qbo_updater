#!/usr/bin/env python3
"""
Demonstrate how aliases SHOULD work in the refactored system.
"""

import json
import logging
from typing import Any, Dict, List

logging.basicConfig(level=logging.INFO, format="%(message)s")
logger = logging.getLogger(__name__)

# Example of what structured extraction SHOULD produce
PROPER_PAYMENT_RECORDS = [
    {
        "payment_info": {
            "payment_method": "handwritten_check",
            "check_no": "8117",
            "amount": 100.00,
            "payment_date": "2025-05-14",
            "deposit_date": "2025-05-14",
            "deposit_method": "ATM Deposit",
        },
        "payer_info": {
            # THIS IS THE KEY - aliases should be generated by Gemini
            "aliases": [
                "J. Lang",  # As written on check
                "Lang, J.",  # Last, First format
                "J Lang",  # Without period
                "Lang J",  # Alternative format
            ],
            "salutation": None,
            "organization_name": None,
        },
        "contact_info": {"address_line_1": None, "city": None, "state": None, "zip": None},
    }
]

# QuickBooks customer data
QBO_CUSTOMERS = {
    "Lang, John D. & Esther A.": {
        "Id": "1234",
        "DisplayName": "Lang, John D. & Esther A.",
        "GivenName": "John & Esther",
        "FamilyName": "Lang",
        "BillAddr": {"Line1": "PO Box 982", "City": "Emory", "CountrySubDivisionCode": "VA", "PostalCode": "24327"},
    }
}


def match_using_aliases(payment_record: Dict[str, Any], qbo_customers: Dict[str, Any]) -> Dict[str, Any]:
    """Match payments to QBO customers using aliases."""

    payer_info = payment_record["payer_info"]
    aliases = payer_info.get("aliases", [])

    logger.info("=" * 60)
    logger.info("MATCHING WITH ALIASES")
    logger.info("=" * 60)

    logger.info(f"\nPayment aliases: {aliases}")

    # Try each alias
    for alias in aliases:
        logger.info(f"\nTrying alias: '{alias}'")

        # Check each QBO customer
        for qbo_name, customer in qbo_customers.items():
            # Extract components for matching
            qbo_last_name = customer.get("FamilyName", "").lower()
            qbo_display = customer.get("DisplayName", "").lower()

            alias_lower = alias.lower()

            # Smart matching logic
            # 1. Check if alias last name matches QBO last name
            alias_parts = alias.split()
            if alias_parts:
                # Handle "Last, First" format
                if "," in alias:
                    alias_last = alias.split(",")[0].strip().lower()
                else:
                    # Assume last word is last name
                    alias_last = alias_parts[-1].lower()

                logger.info(f"  Checking if alias last name '{alias_last}' matches QBO last name '{qbo_last_name}'")

                if alias_last == qbo_last_name:
                    logger.info(f"  ✅ MATCH FOUND! '{alias}' matches '{qbo_name}' by last name")
                    return {
                        "matched": True,
                        "qbo_customer": customer,
                        "match_method": "alias_last_name",
                        "matched_alias": alias,
                    }

            # 2. Check if alias is contained in QBO display name
            if alias_lower in qbo_display:
                logger.info(f"  ✅ MATCH FOUND! '{alias}' is contained in '{qbo_name}'")
                return {
                    "matched": True,
                    "qbo_customer": customer,
                    "match_method": "alias_substring",
                    "matched_alias": alias,
                }

    logger.info("\n❌ No match found using aliases")
    return {"matched": False}


def demonstrate_proper_workflow():
    """Show how the system should work."""

    logger.info("\nDEMONSTRATING PROPER ALIAS-BASED MATCHING")
    logger.info("=========================================\n")

    logger.info("1. EXTRACTION PHASE (Single Gemini API call)")
    logger.info("   - Gemini extracts payment data")
    logger.info("   - Gemini generates multiple aliases for names")
    logger.info("   - Example: 'J. Lang' → ['J. Lang', 'Lang, J.', 'J Lang', 'Lang J']")

    payment = PROPER_PAYMENT_RECORDS[0]
    logger.info(f"\n   Extracted payment with aliases:")
    logger.info(f"   {json.dumps(payment['payer_info'], indent=2)}")

    logger.info("\n2. MATCHING PHASE (No additional Gemini calls)")
    logger.info("   - System uses aliases to search QBO")
    logger.info("   - Smart matching on last names and substrings")

    result = match_using_aliases(payment, QBO_CUSTOMERS)

    if result["matched"]:
        logger.info(f"\n3. RESULT: Successfully matched!")
        logger.info(f"   - Alias '{result['matched_alias']}' matched '{result['qbo_customer']['DisplayName']}'")
        logger.info(f"   - Match method: {result['match_method']}")
        logger.info(f"   - QBO Customer ID: {result['qbo_customer']['Id']}")
    else:
        logger.info("\n3. RESULT: No match found")

    logger.info("\n" + "=" * 60)
    logger.info("KEY BENEFITS:")
    logger.info("=" * 60)
    logger.info("✅ Only ONE Gemini API call needed (during extraction)")
    logger.info("✅ No verification API calls required")
    logger.info("✅ Handles name variations automatically")
    logger.info("✅ J. Lang successfully matches John D. & Esther A. Lang")


if __name__ == "__main__":
    demonstrate_proper_workflow()
